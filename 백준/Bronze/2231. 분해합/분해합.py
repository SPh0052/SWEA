'''
조금 오래 걸렸다.
N-(len(N)*9) 해서 탐색범위를 가지치기 하면
더 빨라질 수 있을텐데 하고.
그런데 문제는 N의 자리수 이다.
생성자가 99라면, N의 자리수는 117로 3자리이다.
생성자와 N의 자리수는 항상 같지 않다.

https://aaaaaaaaaaayowooji.tistory.com/60#google_vignette
역시나 나와 같은 생각이 있었다. 이게 돌려지는지 궁금해서 이 사람 코드를 백준에서 돌려봤따.
아니 왜 맞았는데...?? 어이없어
'''
'''
i ≥ n - 9 * (자리 수)
그렇다면 max(1, ...) 부분의 max는 왜 필요할까요?
오류 방지 + 탐색 범위 보호
n이 매우 작을 때, 예: n = 5
n - len(str(n)) * 9
5 - 1*9 = -4
와 max를 안전장치로도 쓸수 있구나, 천잰가..???
'''
'''
이거 '생성자 자리수 = N의 자리수'가 항상 같지 않잖아. 그것도 해결된거지? 수식에 대입해봤을 때 해결된 것 같은데 이게 왜 논리적으로? 문맥적으로 해결이 된건지 이해가 되지 않아.
“생성자는 n보다 자리 수가 같거나 적을 수만 있고,
더 클 수는 없다.
그래서 len(str(n)) 기준으로 최악의(최대 자리 수)만 계산해도
모든 가능한 생성자를 포함하게 된다.”
시작점을 넉넉히 잡아서
↓
n보다 클 수 없는 조건 덕에 상한이 보호되고
↓
자리수 합 최대 9*k는 최악의 경우 기준이라 모든 i를 커버하고
↓
실제 정답 판정은 if에서 정확히 체크하니까
↓
자리수 차이 상관없이 정답을 찾아낼 수 있다 ✅
'''
n = int(input())
for i in range(max(1, n - len(str(n)) * 9), n):
    if i + sum(map(int, str(i))) == n:
        print(i)
        break
else:
    print(0)
#출처: https://aaaaaaaaaaayowooji.tistory.com/60#google_vignette [Just code it:티스토리]
